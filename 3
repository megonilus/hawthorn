#ifndef haw_bytecode
#define haw_bytecode

#include "lexer/token.h"

#include <share/common.h>
#include <share/error.h>

#define MODULE_NAME "opcodes"

typedef enum : uint8_t
{
	OP_CONSTANT,
	OP_CONSTANT_LONG,

	OP_ADD,	 // +
	OP_MUL,	 // *
	OP_SUB,	 // -
	OP_DIV,	 // /
	OP_MOD,	 // %
	OP_IDIV, // //
	OP_NEG,	 // negate
	OP_NOT,	 // !
	OP_POW,	 // ^
	OP_AND,	 // and
	OP_OR,	 // or
	OP_GE,	 // >=
	OP_LE,	 // <=
	OP_GT,	 // >
	OP_LT,	 // <

	OP_JMP,	 // jump <K>
	OP_JMPF, // jump <K> if pop() false

	OP_SETLOCAL,
	OP_SETGLOBAL,
	OP_LOADLOCAL,
	OP_LOADGLOBAL,

	OP_CALL, // call function

	OP_PRINT,
	OP_RETURN,

	OP_HALT,

	OP_LAST,
} OpCodes;

#define NUM_OPCODES ((int) OP_LAST)

static const char* opnames[NUM_OPCODES] = {
	[OP_CONSTANT]	   = "CONSTANT",
	[OP_CONSTANT_LONG] = "CONSTANT_LONG",
	[OP_ADD]		   = "ADD",
	[OP_MUL]		   = "MUL",
	[OP_SUB]		   = "SUB",
	[OP_DIV]		   = "DIV",
	[OP_MOD]		   = "MOD",
	[OP_IDIV]		   = "IDIV",
	[OP_NEG]		   = "NEG",
	[OP_SETLOCAL]	   = "SETLOCAL",
	[OP_SETGLOBAL]	   = "SETGLOBAL",
	[OP_LOADLOCAL]	   = "LOADLOCAL",
	[OP_LOADGLOBAL]	   = "LOADGLOBAL",
	[OP_CALL]		   = "CALL",
	[OP_RETURN]		   = "RETURN",
	[OP_HALT]		   = "HALT",
	[OP_PRINT]		   = "PRINT",
	[OP_NOT]		   = "NOT",
	[OP_POW]		   = "POW",
	[OP_GE]			   = "GE",
	[OP_GT]			   = "GT",
	[OP_LE]			   = "LE",
	[OP_LT]			   = "LT",
};

typedef enum
{
	// arithmetic
	OPR_BADD,  // a + b
	OPR_BSUB,  // a - b
	OPR_BMUL,  // a * b
	OPR_BDIV,  // a / b
	OPR_BMOD,  // a % b
	OPR_BIDIV, // a // b
	OPR_BPOW,  // a ^ b

	// logical
	OPR_BGE,  // a >= b
	OPR_BLE,  // a <= b
	OPR_BGT,  // a > b
	OPR_BLT,  // a < b
	OPR_BAND, // a and b
	OPR_BOR,  // a or b
} BinOpr;

typedef enum
{
	OPR_NEGATE, // -
	OPR_NOT,	// !
	OPR_INC,	// ++
	OPR_DEC,	// --
} UnOpr;

#define opcase(ch, opr)                                                                            \
	case ch:                                                                                       \
		return opr;

static BinOpr getbinopr(int op)
{
	switch (op)
	{
		opcase('+', OPR_BADD);
		opcase('-', OPR_BSUB);
		opcase('*', OPR_BMUL);
		opcase('/', OPR_BDIV);
		opcase(TK_IDIV, OPR_BIDIV);
		opcase(TK_AND, OPR_BAND);
		opcase(TK_OR, OPR_BOR);
		opcase(TK_GE, OPR_BGE);
		opcase(TK_LE, OPR_BLE);
		opcase('>', OPR_BGT);
		opcase('<', OPR_BLT);
		opcase('^', OPR_BPOW);
		opcase('%', OPR_BMOD);
	default:
		error("Expected BinaryOperator");
	}
}

static UnOpr getunopr(int op)
{
	switch (op)
	{
		opcase('-', OPR_NEGATE);
		opcase('!', OPR_NOT);

		opcase(TK_INC, OPR_INC);
		opcase(TK_DEC, OPR_DEC);
	default:
		error("Expected UnaryOperator");
	}

#undef opcase
}

// push: how much values pushes to stack
// pop: how much values pops from stack
// jump: does manipulating ip
// has_arg: has argument
// use_k: does use constants
// ret: does manipulate on program execution
#define op_prop(push, pop, jump, has_arg, use_k, ret)                                              \
	(((pop) << 12) | ((push) << 8) | ((jump) << 4) | ((has_arg) << 3) | ((use_k) << 2) |           \
	 ((ret) << 1))

typedef uint16_t opprop_mask;

static const opprop_mask op_props[] = {
	[OP_ADD] = op_prop(2, 1, 0, 0, 0, 0),		[OP_MUL] = op_prop(2, 1, 0, 0, 0, 0),
	[OP_SUB] = op_prop(2, 1, 0, 0, 0, 0),		[OP_DIV] = op_prop(2, 1, 0, 0, 0, 0),
	[OP_IDIV] = op_prop(2, 1, 0, 0, 0, 0),		[OP_MOD] = op_prop(2, 1, 0, 0, 0, 0),
	[OP_NEG] = op_prop(1, 1, 0, 0, 0, 0),		[OP_RETURN] = op_prop(1, 0, 0, 0, 0, 1),
	[OP_CONSTANT] = op_prop(1, 0, 0, 1, 0, 0),	[OP_CONSTANT_LONG] = op_prop(1, 0, 0, 1, 0, 0),
	[OP_SETLOCAL] = op_prop(0, 2, 0, 1, 0, 0),	[OP_SETGLOBAL] = op_prop(0, 2, 0, 1, 0, 0),
	[OP_LOADLOCAL] = op_prop(1, 0, 0, 1, 0, 0), [OP_LOADGLOBAL] = op_prop(1, 0, 0, 1, 0, 0),
	[OP_CALL] = op_prop(0, 0, 0, 1, 0, 0),		[OP_HALT] = op_prop(0, 0, 0, 0, 0, 0),
};

#define op_numarg(op) ((op_props[op] >> 8) & 0xF)
#define op_hasflag(op, flag) (op_props[op] & (flag))

const char* op_name(OpCodes op);

#endif
